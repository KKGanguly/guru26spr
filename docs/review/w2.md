<p align="center">
  <a href="https://github.com/txt/guru26spr/blob/main/README.md"><img 
     src="https://img.shields.io/badge/Home-%23ff5733?style=flat-square&logo=home&logoColor=white" /></a>
  <a href="https://github.com/txt/guru26spr/blob/main/docs/lect/syllabus.md"><img 
      src="https://img.shields.io/badge/Syllabus-%230055ff?style=flat-square&logo=openai&logoColor=white" /></a>
  <a href="https://docs.google.com/spreadsheets/d/1xZfIwkmu6hTJjXico1zIzklt1Tl9-L9j9uHrix9KToU/edit?usp=sharing"><img
      src="https://img.shields.io/badge/Teams-%23ffd700?style=flat-square&logo=users&logoColor=white" /></a>
  <a href="https://moodle-courses2527.wolfware.ncsu.edu/course/view.php?id=8119"><img 
      src="https://img.shields.io/badge/Moodle-%23dc143c?style=flat-square&logo=moodle&logoColor=white" /></a>
  <a href="https://discord.gg/vCCXMfzQ"><img 
      src="https://img.shields.io/badge/Chat-%23008080?style=flat-square&logo=discord&logoColor=white" /></a>
  <a href="https://github.com/txt/guru26spr/blob/main/LICENSE.md"><img 
      src="https://img.shields.io/badge/©%20timm%202026-%234b4b4b?style=flat-square&logoColor=white" /></a></p>
<h1 align="center">:cyclone: CSC491/591: How to be a SE Guru <br>NC State, Spring '26</h1>
<img src="https://raw.githubusercontent.com/txt/guru26spr/refs/heads/main/etc/img/banenr.png"> 

# CSC491/591 Week 2 Review Notes

## Glossary

_Gotta catch 'em all. Spot these in the wild._

### Regular Expressions
- **Pattern** — rules defining valid character sequences
- **Anchor** — `^` start, `$` end; pins match to position
- **Greedy** — match as much as possible (`*`, `+`)
- **Non-greedy** — match as little as possible (`-` in Lua)
- **Capture group** — `()` saves matched text for later use
- **Character class** — `[]` set of allowed chars at one position
- **Metacharacter** — special char with pattern meaning (`.`, `*`, etc.)
- **Escape** — `%` in Lua, `\` elsewhere; makes metachar literal
- **NFA** — nondeterministic finite automaton; multiple simultaneous states
- **DFA** — deterministic FA; exactly one state at a time
- **Backtracking** — retry failed paths one at a time (slow)
- **Thompson NFA** — push all paths simultaneously (fast, linear)
- **State** — node in the automaton; circle in the diagram
- **Transition** — edge between states; labeled with input char
- **Accept state** — final state; match succeeds if reached

### Lua
- **Table** — Lua's only data structure (array + dict combined)
- **gsub** — global substitution; returns new string + count
- **match** — find first pattern; returns captures or whole match
- **gmatch** — iterator over all matches; use in `for` loop
- **Frontier** — `%f[]` boundary detection between char classes
- **Balanced** — `%bxy` matches nested x...y (e.g., parentheses)
- **Magic chars** — `( ) . % + - * ? [ ] ^ $` need escaping
- **Coercion** — Lua auto-converts strings/numbers in some contexts
- **Nil** — Lua's "nothing" value; falsy with `false`

### Python OOP
- **Dunder** — double underscore methods (`__x__`); Python's hooks
- **`__dict__`** — object's attribute dictionary; introspection window
- **`__repr__`** — unambiguous debug string; `repr(x)`
- **`__str__`** — user-friendly string; `print(x)` tries this first
- **`__call__`** — makes object callable like a function
- **Polymorphism** — same interface, different behavior per type
- **Duck typing** — if it quacks, it's a duck; behavior over type
- **Open-closed** — open for extension, closed for modification
- **Inheritance** — child class gets parent's methods/attributes
- **Class variable** — shared across all instances; config storage
- **Instance variable** — per-object; lives in `self.__dict__`
- **Dataclass** — decorator; auto-generates `__init__`, `__repr__`
- **SimpleNamespace** — lightweight container; dot-access to attrs
- **Dict comprehension** — `{k: v for k, v in ...}`; compact transform

### Functions
- **First-class** — functions are values; assign, pass, return
- **Higher-order** — function that takes/returns functions
- **Closure** — function + captured environment from birth scope
- **Lexical scope** — variables resolved where function defined
- **Dispatch table** — map keys → functions; data-driven control
- **Anonymous function** — `lambda` in Python, `function() end` in Lua

### Prompt Engineering
- **Iteration** — refine prompts incrementally; rarely right first time
- **Hallucination** — confident wrong answers; LLM doesn't "know"
- **Multi-LLM** — compare outputs across models; triangulate truth
- **Specificity** — precise prompts yield precise answers
- **Constraints** — tell LLM line limits, style, format explicitly

---

## Key Principles (10)

**1. "Regular expressions are the duct tape of text processing."**

One-liners replace pages of parsing code. Learn them once, use forever.

```lua
s = s:gsub("foo", "bar")           -- global find/replace
s = s:gsub("%s+", " ")             -- collapse whitespace
e = s:match("(%S+@%S+)")           -- extract email
```

**2. Simple ain't stupid.**

Fewer lines = fewer bugs. Dict comprehension + `__dict__` = custom repr
in 4 lines.

```python
class Thing:
    DECIMALS = 2
    def __repr__(s):
        d = {k: round(v, s.DECIMALS) for k, v in s.__dict__.items()
             if isinstance(v, float)}
        return f"{type(s).__name__}{d}"
```

**3. Greedy vs non-greedy changes everything.**

Greedy grabs max; non-greedy grabs min. Same pattern, opposite behavior.

```lua
"aaa":match("a+")   --> "aaa"   (greedy: all the a's)
"aaa":match("a-")   --> ""      (non-greedy: zero is valid!)
"aaa":match("a-a")  --> "aa"    (non-greedy but needs final a)

-- The tag trap:
s = "<b>x</b><b>y</b>"
s:match("<b>.*</b>")   --> "<b>x</b><b>y</b>"  (greedy overshoots)
s:match("<b>.-</b>")   --> "<b>x</b>"          (non-greedy stops early)
```

**4. Thompson beats backtracking by orders of magnitude.**

Backtracking: try one path, fail, retry. Exponential on pathological input.
Thompson: track all possible states simultaneously. Linear time always.

```
Pattern: (a+)+
Input:   "aaaaaaaaaaaaaaaaaaaaaaaaaaaa!"

Backtracking: tries 2^28 combinations. Hangs.
Thompson NFA: 28 steps. Done.
```

The 1968 algorithm is still faster than most modern regex engines.

**5. `__dict__` is your introspection window.**

Every object's attributes live in a dictionary. Loop it, filter it,
transform it.

```python
# Print all attributes
for k, v in self.__dict__.items():
    print(f"{k} = {v}")

# Filter to just floats
floats = {k: v for k, v in self.__dict__.items() if isinstance(v, float)}

# Round all floats
rounded = {k: round(v, 2) if isinstance(v, float) else v
           for k, v in self.__dict__.items()}
```

**6. Inheritance carries config, not just behavior.**

Class variables are inherited. Put config in parent, override in child.
Open for extension (subclass), closed for modification (don't edit parent).

```python
class Thing:
    DECIMALS = 2                    # default config
    def __repr__(s): ...            # uses s.DECIMALS

class Car(Thing):
    DECIMALS = 4                    # override config
    def __init__(s, make, speed):
        s.make, s.speed = make, speed
    # inherits __repr__, but now uses DECIMALS=4

class Money(Thing):
    DECIMALS = 0                    # whole dollars only
```

**7. First-class functions enable dispatch tables.**

Functions are values. Store them in tables. Call by lookup. No `if/elif`
chains needed.

```lua
cli = {}
cli["-h"] = function(_) print(help) end
cli["-v"] = function(_) print(version) end
cli["-f"] = function(x) load_file(x) end

-- Usage: script.lua -f data.csv
local flag, arg = arg[1], arg[2]
if cli[flag] then
    cli[flag](arg)
else
    print("Unknown flag: " .. flag)
end
```

**8. Closures capture their birth environment.**

A function remembers variables from where it was *defined*, not where
it's *called*. This enables factories, private state, callbacks.

```lua
function counter(start)
    local n = start or 0           -- captured by closure
    return function()
        n = n + 1                   -- modifies captured n
        return n
    end
end

local c1 = counter(0)
local c2 = counter(100)
print(c1(), c1(), c1())   --> 1  2  3
print(c2(), c2())         --> 101  102
```

**9. Ask more than one LLM.**

Same prompt, different models, different answers. Compare:

| Prompt | ChatGPT | Claude | Gemini |
|--------|---------|--------|--------|
| Thing class | Works | Works | Has bug |
| Explains self | Verbose | Concise | Offers more |

Gemini offered `SimpleNamespace` improvement unprompted—useful!
But its `__repr__` had the `type(self)` bug. Trust, but verify.

**10. LLMs are (sometimes) stupid.**

They hallucinate confidently. They don't "know"—they predict plausible
next tokens. Always:

- Test generated code
- Check edge cases
- Read the output critically
- Ask "does this actually work?"

```python
# LLM wrote this:
def __repr__(s):
    return f"Thing{...}"    # BUG: always says "Thing"

# Should be:
def __repr__(s):
    return f"{type(s).__name__}{...}"  # actual class name
```

---
 
## Gotchas & Bugs (5)

**1. The `type(self)` bug**

Gemini's `Thing.__repr__` hardcoded the class name:
```python
return f"Thing{d}"          # WRONG: Car prints as "Thing"
return f"{type(s).__name__}{d}"  # RIGHT: prints actual class
```
When subclass `Car(Thing)` inherits `__repr__`, it should print "Car",
not "Thing". Use `type(self).__name__` or `self.__class__.__name__`.

**2. Backtracking regex on adversarial input**

Pattern `(a+)+` looks harmless. On input `"aaa...!"` with no final match,
backtracking tries every partition of the a's. 20 a's = 1M+ attempts.

 
- Safe: use possessive/atomic groups (not in Lua)
- Safe: restructure pattern to avoid nested quantifiers
- Best: use Thompson-style engine (grep, awk, Go)
 

**3. Frontier pattern needs both sides**

`%f[]` matches the *boundary* between character classes. Must specify
what's on both sides.

```lua
-- Replace "old" only as whole word:
s:gsub("%f[%w]old%f[%W]", "new")
--      ^^^^^^     ^^^^^^
--      non-word   non-word
--      to word    to non-word

-- WRONG (incomplete):
s:gsub("%f[%w]old", "new")      -- matches "old" in "older"
```

**4. Greedy `.*` overshoots**

Greedy quantifiers go as far as possible, then backtrack. They often
grab too much.

```lua
s = "<b>one</b> and <b>two</b>"

-- WRONG: matches entire string
s:match("<b>.*</b>")   --> "<b>one</b> and <b>two</b>"

-- RIGHT: non-greedy stops at first </b>
s:match("<b>.-</b>")   --> "<b>one</b>"

-- ALSO RIGHT: negated class
s:match("<b>[^<]*</b>") --> "<b>one</b>"
```

**5. `__repr__` vs `__str__` confusion**

- `repr(x)` always calls `__repr__`
- `print(x)` calls `__str__` first, falls back to `__repr__`
- `__repr__` should be unambiguous (ideally valid Python)
- `__str__` should be human-friendly

```python
class Money:
    def __init__(s, amt): s.amt = amt
    def __repr__(s): return f"Money({s.amt})"   # for debugging
    def __str__(s):  return f"${s.amt:.2f}"     # for users

m = Money(50)
print(m)        # $50.00  (uses __str__)
print(repr(m))  # Money(50)
print([m])      # [Money(50)]  (list uses repr on elements!)
```

If you only define one, define `__repr__`. It's the fallback.

---

## Cheat Sheet: Lua Patterns

### Metacharacters
```
^       Start of string         $       End of string
.       Any single character    %       Escape next char
*       0 or more (greedy)      +       1 or more (greedy)
-       0 or more (non-greedy)  ?       0 or 1 (optional)
[]      Character class         [^]     Negated class
()      Capture group           %n      Back-reference (n=1-9)
```

### Predefined Classes
```
%s      Whitespace (space, tab, newline)
%S      Non-whitespace
%d      Digit [0-9]
%D      Non-digit
%w      Alphanumeric [A-Za-z0-9]
%W      Non-alphanumeric
%a      Letter [A-Za-z]
%l      Lowercase [a-z]
%u      Uppercase [A-Z]
%p      Punctuation
%c      Control character
%x      Hexadecimal digit
%z      Zero (char 0)
```

### Special Patterns
```
%bxy    Balanced: matches x...y with nesting
        %b()  matches (a(b)c) entirely
        %b{}  matches {nested{braces}}

%f[set] Frontier: matches boundary where prev char NOT in set,
        next char IS in set
        %f[%w]  word start
        %f[%W]  word end (technically: entering non-word)
```

### The 10 Editing Tasks

```lua
-- 1. Find & Replace
s = s:gsub("foo", "bar")

-- 2. Trim leading whitespace
s = s:gsub("^%s+", "")

-- 3. Trim trailing whitespace
s = s:gsub("%s+$", "")

-- 4. Collapse multiple spaces to one
s = s:gsub("%s+", " ")

-- 5. Remove blank lines
s = s:gsub("\n%s*\n", "\n")

-- 6. Extract email address
email = s:match("(%S+@%S+)")

-- 7. Swap "Last, First" to "First Last"
s = s:gsub("(%w+),%s*(%w+)", "%2 %1")

-- 8. Replace whole word only (not substrings)
s = s:gsub("%f[%w]old%f[%W]", "new")

-- 9. Validate YYYY-MM-DD format
ok = s:match("^%d%d%d%d%-%d%d%-%d%d$") ~= nil

-- 10. Join wrapped lines (preserve space)
s = s:gsub("([^\n])\n(%S)", "%1 %2")

-- 11. Find all balanced parentheses
for x in s:gmatch("%b()") do print(x) end

-- 12. Comment a line (add --)
s = s:gsub("^(%s*)", "%1-- ")

-- 13. Uncomment a line (remove --)
s = s:gsub("^(%s*)%-%-%s?", "%1")
```

---

## Cheat Sheet: Python Dunders

### Object Lifecycle
```
__new__(cls)        Allocate memory (rarely override)
__init__(self)      Initialize attributes (constructor)
__del__(self)       Cleanup (destructor, rare)
```

### String Representations
```
__repr__(self)      Unambiguous string: repr(x), debugger
__str__(self)       Friendly string: print(x), str(x)
__format__(self,f)  Custom formatting: f"{x:spec}"
```

### Container Protocol
```
__len__(self)       len(x)
__getitem__(s,k)    x[k]
__setitem__(s,k,v)  x[k] = v
__delitem__(s,k)    del x[k]
__contains__(s,v)   v in x
__iter__(self)      for i in x (return iterator)
__next__(self)      next(iterator)
```

### Numeric Operators
```
__add__(s,o)        x + y       __radd__    y + x (reversed)
__sub__(s,o)        x - y       __iadd__    x += y (in-place)
__mul__(s,o)        x * y
__truediv__(s,o)    x / y
__floordiv__(s,o)   x // y
__mod__(s,o)        x % y
__pow__(s,o)        x ** y
__neg__(self)       -x
__abs__(self)       abs(x)
```

### Comparison Operators
```
__eq__(s,o)         x == y
__ne__(s,o)         x != y
__lt__(s,o)         x < y
__le__(s,o)         x <= y
__gt__(s,o)         x > y
__ge__(s,o)         x >= y
```

### Callable & Context
```
__call__(s, ...)    x(args)     Make object callable
__enter__(self)     with x:     Setup context
__exit__(s,t,v,tb)  end with    Teardown context
```

### Attribute Access
```
__getattr__(s,n)    x.missing   Called when attr not found
__setattr__(s,n,v)  x.a = 1     Intercept all assignment
__delattr__(s,n)    del x.a     Intercept deletion
__dict__            Attribute dictionary (instance)
__class__           Reference to class object
```

### Minimal Complete Example

```python
from types import SimpleNamespace as obj

class Thing(obj):
    """Base class with configurable decimal formatting."""
    DECIMALS = 2

    def __repr__(s):
        d = {k: round(v, s.DECIMALS) if isinstance(v, float) else v
             for k, v in s.__dict__.items()}
        return f"{type(s).__name__}{d}"

    def __add__(s, o):
        """Merge two Things; o's values override s's."""
        return type(s)(**{**s.__dict__, **o.__dict__})

    def __call__(s, **kw):
        """Return new Thing with updated values."""
        return type(s)(**{**s.__dict__, **kw})

# Usage
class Car(Thing):
    DECIMALS = 1

c1 = Car(make="mazda", speed=123.456, price=19999.99)
print(c1)              # Car{'make': 'mazda', 'speed': 123.5, 'price': 20000.0}
c2 = c1(speed=150.0)   # clone with new speed
print(c2)              # Car{'make': 'mazda', 'speed': 150.0, 'price': 20000.0}
```

---

## Hints: Prompt Engineering

1. **Be specific.** "Write a Python class" < "Write a minimal Python class
   Thing with DECIMALS=2 and __repr__ that rounds floats."

2. **Specify constraints.** "Under 80 chars per line. Fewest lines possible.
   No external dependencies."

3. **Show examples.** "Before: `foo = 1.234`, After: `foo = 1.23`"

4. **Ask for demos.** "Write a demo showing this working with 2 test cases."

5. **Iterate.** First answer rarely perfect. "Now make it shorter."
   "What about edge case X?"

6. **Multi-LLM.** Ask ChatGPT, Claude, Gemini. Compare. Pick best parts.
   One might offer `SimpleNamespace`, another might have a bug.

7. **Verify everything.** Run the code. Check edge cases. LLMs hallucinate.
   If it looks too clever, it's probably wrong.

8. **Ask for alternatives.** "Is there something more succinct than
   dataclass?" → might get `SimpleNamespace` suggestion.

9. **Name the pattern.** "Use dictionary comprehension" > "make it compact"

10. **Request critique.** "What's wrong with this code?" LLMs are often
    better at reviewing than generating.

---

## Hints: Lua

1. **Only one data structure.** Tables do everything: arrays, dicts,
   objects, modules. `t = {}` then `t[1]`, `t["key"]`, `t.key` all work.

2. **1-indexed arrays.** `t[1]` is first element, not `t[0]`. Length is
   `#t`. Iterate with `for i=1,#t do`.

3. **Strings are immutable.** `gsub` returns new string, doesn't modify.
   Always capture the result: `s = s:gsub(...)`.

4. **Patterns, not regex.** Lua has "patterns"—simpler than PCRE.
   No `|` alternation. No `\d`, use `%d`. Escape with `%`, not `\`.

5. **`match` returns captures or whole match.** With `()`: returns
   captured groups. Without: returns entire match. Returns `nil` on fail.

6. **`gmatch` for iteration.** Returns iterator, use in for loop:
   `for word in s:gmatch("%w+") do`.

7. **`gsub` returns two values.** New string and replacement count.
   `s, n = s:gsub("a", "b")`.

8. **`%b` for balanced.** `%b()` matches `(nested(parens))` correctly.
   Works with any two different characters: `%b{}`, `%b[]`, `%b<>`.

9. **`%f` for boundaries.** `%f[%w]` = entering word, `%f[%W]` = leaving.
   Combine: `%f[%w]word%f[%W]` for whole-word match.

10. **Test incrementally.** Patterns are easy to get wrong. Build up:
    first `%d+`, then `%d+%-%d+`, then `^%d+%-%d+%-%d+$`.

---

## Review Questions (12)

### Q1. Finite Automata
**a)** Define NFA. What makes it "nondeterministic"? _(2 min)_

**b)** Draw the state diagram for pattern `a(bb)+a`. Trace the path for
input "abbbba". What happens on input "abbba"? _(4 min)_

---

### Q2. Thompson vs Backtracking
**a)** What is backtracking in regex matching? _(2 min)_

**b)** Explain why `(a+)+` causes exponential time with backtracking but
linear time with Thompson NFA. What's the key difference? _(4 min)_

---

### Q3. Greedy vs Non-Greedy
**a)** In Lua, what's the difference between `+` and `-`? _(2 min)_

**b)** Given `s = "<b>x</b><b>y</b>"`, write a pattern to extract only
the first bold tag `<b>x</b>`. Explain why `<b>.*</b>` fails. _(4 min)_

---

### Q4. Capture Groups
**a)** What do parentheses `()` do in a Lua pattern? _(2 min)_

**b)** Write a `gsub` that converts "2026-01-21" to "January 21, 2026".
You may assume a helper table `months = {["01"]="January", ...}`. _(4 min)_

---

### Q5. Frontier Pattern
**a)** What does `%f[%w]` match? What about `%f[%W]`? _(2 min)_

**b)** String `s = "old older bold old."`. Write a `gsub` to replace
only standalone "old" with "new", leaving "older" and "bold" intact.
Show expected output. _(4 min)_

---

### Q6. `__repr__` and `__str__`
**a)** When is `__repr__` called vs `__str__`? _(2 min)_

**b)** Write a `Money` class where `print(m)` shows "$50.00" but `repr(m)`
shows `Money(50)`. What happens with `print([m, m])`? Why? _(4 min)_

---

### Q7. `__dict__` Introspection
**a)** What is `self.__dict__`? What's in it? _(2 min)_

**b)** Write a `__repr__` method that prints only float attributes,
rounded to `self.DECIMALS` places. Use dict comprehension. Handle the
case where some attributes aren't floats. _(4 min)_

---

### Q8. Open-Closed Principle
**a)** What does "open for extension, closed for modification" mean? _(2 min)_

**b)** Show how a class variable `DECIMALS` in a parent class `Thing`
allows subclasses `Car` and `Money` to customize formatting without
modifying `Thing.__repr__`. Write the code. _(4 min)_

---

### Q9. First-Class Functions
**a)** What does it mean for functions to be "first-class"? _(2 min)_

**b)** Write a Lua dispatch table that handles `-h` (print help), `-v`
(print version), and `-n` (print a number argument). Show how to call
it from command-line args. _(4 min)_

---

### Q10. Closures
**a)** What is a closure? What does it "close over"? _(2 min)_

**b)** Write a Lua function `make_counter(start)` that returns a function.
Each call to that function returns the next integer. Two counters should
be independent. Demonstrate with code. _(4 min)_

---

### Q11. LLM Comparison
**a)** Why should you ask the same prompt to multiple LLMs? _(2 min)_

**b)** You asked three LLMs for a `Thing` class. Outputs below. Which
has a bug? What's the bug? How do you fix it? _(4 min)_

```python
# LLM-A
class Thing:
    DECIMALS = 2
    def __repr__(s):
        d = {k: round(v, s.DECIMALS) for k, v in s.__dict__.items()
             if isinstance(v, float)}
        return f"Thing{d}"

# LLM-B
class Thing:
    DECIMALS = 2
    def __repr__(s):
        d = {k: round(v, s.DECIMALS) for k, v in s.__dict__.items()
             if isinstance(v, float)}
        return f"{type(s).__name__}{d}"
```

---

### Q12. Debugging LLM Output
**a)** What is "hallucination" in LLM output? _(2 min)_

**b)** An LLM gives you this Lua pattern to match email addresses:
`%w+@%w+%.%w+`. Test it on "user@sub.example.com" and "a.b@c.org".
What fails? Write a better pattern. _(4 min)_

